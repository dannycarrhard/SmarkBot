/* 
 * Smarkets HTTP API
 *
 * This is the HTTP trading API for Smarkets. It can be used to trade on our exchange.     <br><br>For authenticated requests:<br>     <ul>     <li>Get a session token using the login route:     <a class=\"nostyle\" href=\"#/sessions/create_session\"><span>GET /v3/sessions/</span></a></li>     <li>Click on 'Authorize ðŸ”“', enter your token after 'Session-Token ' and click on the 'Authorize' button</li>     </ul>     <p>In order to place bets and get the latest prices without restrictions     using this API, you need to be a Smarkets API user.<br></p>     <p>To become one, please fill <a href=\"https://docs.google.com/forms/d/1qI8RqypNimakPx- bmoUE_lA0YSP3YogKfL8N14STNSM/viewform?edit_requested=true\">this form</a>.</p>     <p>For questions and feedback about the API, use <a href=\"https://community.smarkets.com/c/developers\">our forum</a>.</p>     <p>The API is not public, but we are granting users access on an ongoing basis.</p>     <p>You can find some sample code to help you bootstrap your integration <a href=\"https://github.com/ smarkets/smk_trading_bot\">here</a>.</p>     
 *
 * OpenAPI spec version: 3
 * Contact: api@smarkets.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// OrderResponse1
    /// </summary>
    [DataContract]
        public partial class OrderResponse1 :  IEquatable<OrderResponse1>, IValidatableObject
    {
        /// <summary>
        ///  The outcome of the contract can be:&lt;br&gt; &lt;/ul&gt; &lt;li&gt;winner: This contract is the winner or one of the winners of the market &lt;li&gt;loser: This contract is a loser &lt;li&gt;deadheat: There was a tie between this contract and another one. This is quite a rare outcome. &lt;li&gt;reduce: This contract was withdrawn from the market and a reduction factor was applied. &lt;li&gt;void: This contract is no longer allowed to be traded on. &lt;/ul&gt;     
        /// </summary>
        /// <value> The outcome of the contract can be:&lt;br&gt; &lt;/ul&gt; &lt;li&gt;winner: This contract is the winner or one of the winners of the market &lt;li&gt;loser: This contract is a loser &lt;li&gt;deadheat: There was a tie between this contract and another one. This is quite a rare outcome. &lt;li&gt;reduce: This contract was withdrawn from the market and a reduction factor was applied. &lt;li&gt;void: This contract is no longer allowed to be traded on. &lt;/ul&gt;     </value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum OutcomeEnum
        {
            /// <summary>
            /// Enum Winner for value: winner
            /// </summary>
            [EnumMember(Value = "winner")]
            Winner = 1,
            /// <summary>
            /// Enum Loser for value: loser
            /// </summary>
            [EnumMember(Value = "loser")]
            Loser = 2,
            /// <summary>
            /// Enum Deadheat for value: deadheat
            /// </summary>
            [EnumMember(Value = "deadheat")]
            Deadheat = 3,
            /// <summary>
            /// Enum Reduce for value: reduce
            /// </summary>
            [EnumMember(Value = "reduce")]
            Reduce = 4,
            /// <summary>
            /// Enum Void for value: void
            /// </summary>
            [EnumMember(Value = "void")]
            Void = 5        }
        /// <summary>
        ///  The outcome of the contract can be:&lt;br&gt; &lt;/ul&gt; &lt;li&gt;winner: This contract is the winner or one of the winners of the market &lt;li&gt;loser: This contract is a loser &lt;li&gt;deadheat: There was a tie between this contract and another one. This is quite a rare outcome. &lt;li&gt;reduce: This contract was withdrawn from the market and a reduction factor was applied. &lt;li&gt;void: This contract is no longer allowed to be traded on. &lt;/ul&gt;     
        /// </summary>
        /// <value> The outcome of the contract can be:&lt;br&gt; &lt;/ul&gt; &lt;li&gt;winner: This contract is the winner or one of the winners of the market &lt;li&gt;loser: This contract is a loser &lt;li&gt;deadheat: There was a tie between this contract and another one. This is quite a rare outcome. &lt;li&gt;reduce: This contract was withdrawn from the market and a reduction factor was applied. &lt;li&gt;void: This contract is no longer allowed to be traded on. &lt;/ul&gt;     </value>
        [DataMember(Name="outcome", EmitDefaultValue=false)]
        public OutcomeEnum? Outcome { get; set; }
        /// <summary>
        ///  side can either be:&lt;ul&gt; &lt;li&gt;buy: backing a contract &lt;li&gt;sell: laying a contract &lt;/ul&gt;
        /// </summary>
        /// <value> side can either be:&lt;ul&gt; &lt;li&gt;buy: backing a contract &lt;li&gt;sell: laying a contract &lt;/ul&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum SideEnum
        {
            /// <summary>
            /// Enum Buy for value: buy
            /// </summary>
            [EnumMember(Value = "buy")]
            Buy = 1,
            /// <summary>
            /// Enum Sell for value: sell
            /// </summary>
            [EnumMember(Value = "sell")]
            Sell = 2        }
        /// <summary>
        ///  side can either be:&lt;ul&gt; &lt;li&gt;buy: backing a contract &lt;li&gt;sell: laying a contract &lt;/ul&gt;
        /// </summary>
        /// <value> side can either be:&lt;ul&gt; &lt;li&gt;buy: backing a contract &lt;li&gt;sell: laying a contract &lt;/ul&gt;</value>
        [DataMember(Name="side", EmitDefaultValue=false)]
        public SideEnum Side { get; set; }
        /// <summary>
        ///  Order state can be one of four values: &lt;ul&gt; &lt;li&gt;created: The first state of the order after creation, this order is unmatched &lt;li&gt;partial: The order is partially matched &lt;li&gt;filled: The order is fully matched &lt;li&gt;settled: The order has settled, the final state of orders.     
        /// </summary>
        /// <value> Order state can be one of four values: &lt;ul&gt; &lt;li&gt;created: The first state of the order after creation, this order is unmatched &lt;li&gt;partial: The order is partially matched &lt;li&gt;filled: The order is fully matched &lt;li&gt;settled: The order has settled, the final state of orders.     </value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum StateEnum
        {
            /// <summary>
            /// Enum Created for value: created
            /// </summary>
            [EnumMember(Value = "created")]
            Created = 1,
            /// <summary>
            /// Enum Partial for value: partial
            /// </summary>
            [EnumMember(Value = "partial")]
            Partial = 2,
            /// <summary>
            /// Enum Filled for value: filled
            /// </summary>
            [EnumMember(Value = "filled")]
            Filled = 3,
            /// <summary>
            /// Enum Settled for value: settled
            /// </summary>
            [EnumMember(Value = "settled")]
            Settled = 4        }
        /// <summary>
        ///  Order state can be one of four values: &lt;ul&gt; &lt;li&gt;created: The first state of the order after creation, this order is unmatched &lt;li&gt;partial: The order is partially matched &lt;li&gt;filled: The order is fully matched &lt;li&gt;settled: The order has settled, the final state of orders.     
        /// </summary>
        /// <value> Order state can be one of four values: &lt;ul&gt; &lt;li&gt;created: The first state of the order after creation, this order is unmatched &lt;li&gt;partial: The order is partially matched &lt;li&gt;filled: The order is fully matched &lt;li&gt;settled: The order has settled, the final state of orders.     </value>
        [DataMember(Name="state", EmitDefaultValue=false)]
        public StateEnum State { get; set; }
        /// <summary>
        /// Order types can have the following values:     &lt;ul&gt;     &lt;li&gt;good_til_cancelled: this order will be open until a reduction     factor is applied or a market state changes to live, which will cancel the order.     &lt;li&gt;keep_in_play: the same as good_til_cancelled,     except it will not be cancelled on market state changes     &lt;li&gt;good_til_halted: the same as good_til_cancelled, except a market     &lt;li&gt;immediate_or_cancel: if the minimum_accepted_quantity is not     matched at the time of order placement, this order will be cancelled.  &lt;li&gt;over_the_counter: this order was matched right after being created.     &lt;/ul&gt;     &lt;p&gt;The following table explains the lifetime of orders:&lt;/p&gt;     &lt;table cellpadding&#x3D;\&quot;3\&quot; style&#x3D;\&quot;border: 1px solid white;\&quot;&gt;       &lt;tr&gt;         &lt;th&gt;order_type&lt;/th&gt;         &lt;th&gt;Market Goes Live&lt;/th&gt;         &lt;th&gt;Market Halted&lt;/th&gt;         &lt;th&gt;Reduction Factor Applied&lt;/th&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_halted&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;keep_in_play&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;     &lt;/table&gt;&lt;br&gt;     &lt;p&gt;Orders marked as immediate_or_cancel must be executed     immediately and thus will not remain in the book.&lt;/p&gt;     &lt;p&gt;Same happens to orders marked as over_the_counter which are executed immediately.&lt;/p&gt;
        /// </summary>
        /// <value>Order types can have the following values:     &lt;ul&gt;     &lt;li&gt;good_til_cancelled: this order will be open until a reduction     factor is applied or a market state changes to live, which will cancel the order.     &lt;li&gt;keep_in_play: the same as good_til_cancelled,     except it will not be cancelled on market state changes     &lt;li&gt;good_til_halted: the same as good_til_cancelled, except a market     &lt;li&gt;immediate_or_cancel: if the minimum_accepted_quantity is not     matched at the time of order placement, this order will be cancelled.  &lt;li&gt;over_the_counter: this order was matched right after being created.     &lt;/ul&gt;     &lt;p&gt;The following table explains the lifetime of orders:&lt;/p&gt;     &lt;table cellpadding&#x3D;\&quot;3\&quot; style&#x3D;\&quot;border: 1px solid white;\&quot;&gt;       &lt;tr&gt;         &lt;th&gt;order_type&lt;/th&gt;         &lt;th&gt;Market Goes Live&lt;/th&gt;         &lt;th&gt;Market Halted&lt;/th&gt;         &lt;th&gt;Reduction Factor Applied&lt;/th&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_halted&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;keep_in_play&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;     &lt;/table&gt;&lt;br&gt;     &lt;p&gt;Orders marked as immediate_or_cancel must be executed     immediately and thus will not remain in the book.&lt;/p&gt;     &lt;p&gt;Same happens to orders marked as over_the_counter which are executed immediately.&lt;/p&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum TypeEnum
        {
            /// <summary>
            /// Enum Goodtilcancelled for value: good_til_cancelled
            /// </summary>
            [EnumMember(Value = "good_til_cancelled")]
            Goodtilcancelled = 1,
            /// <summary>
            /// Enum Keepinplay for value: keep_in_play
            /// </summary>
            [EnumMember(Value = "keep_in_play")]
            Keepinplay = 2,
            /// <summary>
            /// Enum Goodtilhalted for value: good_til_halted
            /// </summary>
            [EnumMember(Value = "good_til_halted")]
            Goodtilhalted = 3,
            /// <summary>
            /// Enum Immediateorcancel for value: immediate_or_cancel
            /// </summary>
            [EnumMember(Value = "immediate_or_cancel")]
            Immediateorcancel = 4,
            /// <summary>
            /// Enum Overthecounter for value: over_the_counter
            /// </summary>
            [EnumMember(Value = "over_the_counter")]
            Overthecounter = 5        }
        /// <summary>
        /// Order types can have the following values:     &lt;ul&gt;     &lt;li&gt;good_til_cancelled: this order will be open until a reduction     factor is applied or a market state changes to live, which will cancel the order.     &lt;li&gt;keep_in_play: the same as good_til_cancelled,     except it will not be cancelled on market state changes     &lt;li&gt;good_til_halted: the same as good_til_cancelled, except a market     &lt;li&gt;immediate_or_cancel: if the minimum_accepted_quantity is not     matched at the time of order placement, this order will be cancelled.  &lt;li&gt;over_the_counter: this order was matched right after being created.     &lt;/ul&gt;     &lt;p&gt;The following table explains the lifetime of orders:&lt;/p&gt;     &lt;table cellpadding&#x3D;\&quot;3\&quot; style&#x3D;\&quot;border: 1px solid white;\&quot;&gt;       &lt;tr&gt;         &lt;th&gt;order_type&lt;/th&gt;         &lt;th&gt;Market Goes Live&lt;/th&gt;         &lt;th&gt;Market Halted&lt;/th&gt;         &lt;th&gt;Reduction Factor Applied&lt;/th&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_halted&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;keep_in_play&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;     &lt;/table&gt;&lt;br&gt;     &lt;p&gt;Orders marked as immediate_or_cancel must be executed     immediately and thus will not remain in the book.&lt;/p&gt;     &lt;p&gt;Same happens to orders marked as over_the_counter which are executed immediately.&lt;/p&gt;
        /// </summary>
        /// <value>Order types can have the following values:     &lt;ul&gt;     &lt;li&gt;good_til_cancelled: this order will be open until a reduction     factor is applied or a market state changes to live, which will cancel the order.     &lt;li&gt;keep_in_play: the same as good_til_cancelled,     except it will not be cancelled on market state changes     &lt;li&gt;good_til_halted: the same as good_til_cancelled, except a market     &lt;li&gt;immediate_or_cancel: if the minimum_accepted_quantity is not     matched at the time of order placement, this order will be cancelled.  &lt;li&gt;over_the_counter: this order was matched right after being created.     &lt;/ul&gt;     &lt;p&gt;The following table explains the lifetime of orders:&lt;/p&gt;     &lt;table cellpadding&#x3D;\&quot;3\&quot; style&#x3D;\&quot;border: 1px solid white;\&quot;&gt;       &lt;tr&gt;         &lt;th&gt;order_type&lt;/th&gt;         &lt;th&gt;Market Goes Live&lt;/th&gt;         &lt;th&gt;Market Halted&lt;/th&gt;         &lt;th&gt;Reduction Factor Applied&lt;/th&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_halted&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;keep_in_play&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;     &lt;/table&gt;&lt;br&gt;     &lt;p&gt;Orders marked as immediate_or_cancel must be executed     immediately and thus will not remain in the book.&lt;/p&gt;     &lt;p&gt;Same happens to orders marked as over_the_counter which are executed immediately.&lt;/p&gt;</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public TypeEnum? Type { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="OrderResponse1" /> class.
        /// </summary>
        /// <param name="averagePriceMatched"> This price can be different from the order price, as it may have been matched at a better price for the user, according to best price execution rules (required).</param>
        /// <param name="contractId">This ID uniquely identifies the contract (required).</param>
        /// <param name="createdDatetime">When was the order created (required).</param>
        /// <param name="id">This ID uniquely identifies an order (required).</param>
        /// <param name="label">Label is a user-defined string that will be stored in the order. It can be used to identify different trading strategies.</param>
        /// <param name="lastModifiedDatetime">When was the order last modified, usually by the exchange matching it (required).</param>
        /// <param name="marketId">This ID uniquely identifies the market (required).</param>
        /// <param name="originalOrderId">This ID uniquely identifies an order (required).</param>
        /// <param name="outcome"> The outcome of the contract can be:&lt;br&gt; &lt;/ul&gt; &lt;li&gt;winner: This contract is the winner or one of the winners of the market &lt;li&gt;loser: This contract is a loser &lt;li&gt;deadheat: There was a tie between this contract and another one. This is quite a rare outcome. &lt;li&gt;reduce: This contract was withdrawn from the market and a reduction factor was applied. &lt;li&gt;void: This contract is no longer allowed to be traded on. &lt;/ul&gt;     .</param>
        /// <param name="price"> This price is in percentage basis points.&lt;br&gt; Example: 5000 &#x3D; 50% &lt;br&gt; To convert it to decimal odds, just divide 10000 by it&lt;br&gt; Example: 10000 / 5000 &#x3D; 2.0 (decimal odds).&lt;br&gt; This price has to conform to a valid tick on the exchange; an invalid price error will be returned if it does not. (required).</param>
        /// <param name="quantity">     Quantity is the sum of the total pot (back+lay) in case the order is matched&lt;br&gt;     The units are 1/100 of a UK penny.&lt;br&gt;     Example: Quantity 1 &#x3D; 0.0001 GBP&lt;br&gt;     To convert it to back stake, just multiply by the price and divide by 100000000&lt;br&gt;     Example: 100000 (quantity) * 5000 (price) / 100000000 &#x3D; 5 GBP back stake (required).</param>
        /// <param name="quantityFilled">The quantity in GBP of the order that was matched (required).</param>
        /// <param name="quantityFilledPending"> The quantity in GBP of the order that was matched and pending confirmation.&lt;br&gt; Bets will be subject to an eight second â€˜Pendingâ€™ confirmation delay after being matched.&lt;br&gt; If no significant events occur in this period, the bet is confirmed.&lt;br&gt; If our scouting feed tells us that a material event (a goal, red card, or penalty) or a set-piece event (corner or dangerous free-kick) might have occurred, the Pending period is extended until we get confirmation either way.&lt;br&gt; If subsequent messages confirm that a material event has occurred, we void those bets matched in the preceding eight seconds.&lt;br&gt; This is to protect users from courtsiding and faster feeds. (required).</param>
        /// <param name="quantityFilledPendingUserCurrency">The quantity of the order that is matched, but pending confirmation, converted to the user&#x27;s currency (required).</param>
        /// <param name="quantityFilledUserCurrency">The quantity of the order that is matched, converted to the user&#x27;s currency (required).</param>
        /// <param name="quantityUnfilled">The quantity in GBP of the order that is still unmatched (required).</param>
        /// <param name="quantityUnfilledUserCurrency">The quantity of the order that is unmatched, converted to the user&#x27;s currency (required).</param>
        /// <param name="quantityUserCurrency">     Quantity is the sum of the total pot (back+lay) in case the order is matched&lt;br&gt;     The units are 1/10000 * one unit of the user&#x27;s currency.&lt;br&gt;     Example: Quantity 1 &#x3D; 0.0001 GBP&lt;br&gt;     To convert it to back stake, just multiply by the price and divide by 100000000&lt;br&gt;     Example: 100000 (quantity) * 5000 (price) / 100000000 &#x3D; 5 GBP back stake (required).</param>
        /// <param name="sequenceNumber">This refers to the sequence number in the account activity - statement endpoint (required).</param>
        /// <param name="side"> side can either be:&lt;ul&gt; &lt;li&gt;buy: backing a contract &lt;li&gt;sell: laying a contract &lt;/ul&gt; (required).</param>
        /// <param name="state"> Order state can be one of four values: &lt;ul&gt; &lt;li&gt;created: The first state of the order after creation, this order is unmatched &lt;li&gt;partial: The order is partially matched &lt;li&gt;filled: The order is fully matched &lt;li&gt;settled: The order has settled, the final state of orders.      (required).</param>
        /// <param name="type">Order types can have the following values:     &lt;ul&gt;     &lt;li&gt;good_til_cancelled: this order will be open until a reduction     factor is applied or a market state changes to live, which will cancel the order.     &lt;li&gt;keep_in_play: the same as good_til_cancelled,     except it will not be cancelled on market state changes     &lt;li&gt;good_til_halted: the same as good_til_cancelled, except a market     &lt;li&gt;immediate_or_cancel: if the minimum_accepted_quantity is not     matched at the time of order placement, this order will be cancelled.  &lt;li&gt;over_the_counter: this order was matched right after being created.     &lt;/ul&gt;     &lt;p&gt;The following table explains the lifetime of orders:&lt;/p&gt;     &lt;table cellpadding&#x3D;\&quot;3\&quot; style&#x3D;\&quot;border: 1px solid white;\&quot;&gt;       &lt;tr&gt;         &lt;th&gt;order_type&lt;/th&gt;         &lt;th&gt;Market Goes Live&lt;/th&gt;         &lt;th&gt;Market Halted&lt;/th&gt;         &lt;th&gt;Reduction Factor Applied&lt;/th&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;good_til_halted&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;       &lt;tr&gt;         &lt;td&gt;keep_in_play&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Kept&lt;/td&gt;         &lt;td&gt;Cancelled&lt;/td&gt;       &lt;/tr&gt;     &lt;/table&gt;&lt;br&gt;     &lt;p&gt;Orders marked as immediate_or_cancel must be executed     immediately and thus will not remain in the book.&lt;/p&gt;     &lt;p&gt;Same happens to orders marked as over_the_counter which are executed immediately.&lt;/p&gt; (default to TypeEnum.Goodtilhalted).</param>
        public OrderResponse1(int? averagePriceMatched = default(int?), string contractId = default(string), DateTime? createdDatetime = default(DateTime?), string id = default(string), string label = default(string), DateTime? lastModifiedDatetime = default(DateTime?), string marketId = default(string), string originalOrderId = default(string), OutcomeEnum? outcome = default(OutcomeEnum?), int? price = default(int?), int? quantity = default(int?), int? quantityFilled = default(int?), int? quantityFilledPending = default(int?), int? quantityFilledPendingUserCurrency = default(int?), int? quantityFilledUserCurrency = default(int?), int? quantityUnfilled = default(int?), int? quantityUnfilledUserCurrency = default(int?), int? quantityUserCurrency = default(int?), int? sequenceNumber = default(int?), SideEnum side = default(SideEnum), StateEnum state = default(StateEnum), TypeEnum? type = TypeEnum.Goodtilhalted)
        {
            // to ensure "averagePriceMatched" is required (not null)
            if (averagePriceMatched == null)
            {
                throw new InvalidDataException("averagePriceMatched is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.AveragePriceMatched = averagePriceMatched;
            }
            // to ensure "contractId" is required (not null)
            if (contractId == null)
            {
                throw new InvalidDataException("contractId is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.ContractId = contractId;
            }
            // to ensure "createdDatetime" is required (not null)
            if (createdDatetime == null)
            {
                throw new InvalidDataException("createdDatetime is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.CreatedDatetime = createdDatetime;
            }
            // to ensure "id" is required (not null)
            if (id == null)
            {
                throw new InvalidDataException("id is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.Id = id;
            }
            // to ensure "lastModifiedDatetime" is required (not null)
            if (lastModifiedDatetime == null)
            {
                throw new InvalidDataException("lastModifiedDatetime is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.LastModifiedDatetime = lastModifiedDatetime;
            }
            // to ensure "marketId" is required (not null)
            if (marketId == null)
            {
                throw new InvalidDataException("marketId is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.MarketId = marketId;
            }
            // to ensure "originalOrderId" is required (not null)
            if (originalOrderId == null)
            {
                throw new InvalidDataException("originalOrderId is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.OriginalOrderId = originalOrderId;
            }
            // to ensure "price" is required (not null)
            if (price == null)
            {
                throw new InvalidDataException("price is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.Price = price;
            }
            // to ensure "quantity" is required (not null)
            if (quantity == null)
            {
                throw new InvalidDataException("quantity is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.Quantity = quantity;
            }
            // to ensure "quantityFilled" is required (not null)
            if (quantityFilled == null)
            {
                throw new InvalidDataException("quantityFilled is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.QuantityFilled = quantityFilled;
            }
            // to ensure "quantityFilledPending" is required (not null)
            if (quantityFilledPending == null)
            {
                throw new InvalidDataException("quantityFilledPending is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.QuantityFilledPending = quantityFilledPending;
            }
            // to ensure "quantityFilledPendingUserCurrency" is required (not null)
            if (quantityFilledPendingUserCurrency == null)
            {
                throw new InvalidDataException("quantityFilledPendingUserCurrency is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.QuantityFilledPendingUserCurrency = quantityFilledPendingUserCurrency;
            }
            // to ensure "quantityFilledUserCurrency" is required (not null)
            if (quantityFilledUserCurrency == null)
            {
                throw new InvalidDataException("quantityFilledUserCurrency is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.QuantityFilledUserCurrency = quantityFilledUserCurrency;
            }
            // to ensure "quantityUnfilled" is required (not null)
            if (quantityUnfilled == null)
            {
                throw new InvalidDataException("quantityUnfilled is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.QuantityUnfilled = quantityUnfilled;
            }
            // to ensure "quantityUnfilledUserCurrency" is required (not null)
            if (quantityUnfilledUserCurrency == null)
            {
                throw new InvalidDataException("quantityUnfilledUserCurrency is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.QuantityUnfilledUserCurrency = quantityUnfilledUserCurrency;
            }
            // to ensure "quantityUserCurrency" is required (not null)
            if (quantityUserCurrency == null)
            {
                throw new InvalidDataException("quantityUserCurrency is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.QuantityUserCurrency = quantityUserCurrency;
            }
            // to ensure "sequenceNumber" is required (not null)
            if (sequenceNumber == null)
            {
                throw new InvalidDataException("sequenceNumber is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.SequenceNumber = sequenceNumber;
            }
            // to ensure "side" is required (not null)
            if (side == null)
            {
                throw new InvalidDataException("side is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.Side = side;
            }
            // to ensure "state" is required (not null)
            if (state == null)
            {
                throw new InvalidDataException("state is a required property for OrderResponse1 and cannot be null");
            }
            else
            {
                this.State = state;
            }
            this.Label = label;
            this.Outcome = outcome;
            // use default value if no "type" provided
            if (type == null)
            {
                this.Type = TypeEnum.Goodtilhalted;
            }
            else
            {
                this.Type = type;
            }
        }
        
        /// <summary>
        ///  This price can be different from the order price, as it may have been matched at a better price for the user, according to best price execution rules
        /// </summary>
        /// <value> This price can be different from the order price, as it may have been matched at a better price for the user, according to best price execution rules</value>
        [DataMember(Name="average_price_matched", EmitDefaultValue=false)]
        public int? AveragePriceMatched { get; set; }

        /// <summary>
        /// This ID uniquely identifies the contract
        /// </summary>
        /// <value>This ID uniquely identifies the contract</value>
        [DataMember(Name="contract_id", EmitDefaultValue=false)]
        public string ContractId { get; set; }

        /// <summary>
        /// When was the order created
        /// </summary>
        /// <value>When was the order created</value>
        [DataMember(Name="created_datetime", EmitDefaultValue=false)]
        public DateTime? CreatedDatetime { get; set; }

        /// <summary>
        /// This ID uniquely identifies an order
        /// </summary>
        /// <value>This ID uniquely identifies an order</value>
        [DataMember(Name="id", EmitDefaultValue=false)]
        public string Id { get; set; }

        /// <summary>
        /// Label is a user-defined string that will be stored in the order. It can be used to identify different trading strategies
        /// </summary>
        /// <value>Label is a user-defined string that will be stored in the order. It can be used to identify different trading strategies</value>
        [DataMember(Name="label", EmitDefaultValue=false)]
        public string Label { get; set; }

        /// <summary>
        /// When was the order last modified, usually by the exchange matching it
        /// </summary>
        /// <value>When was the order last modified, usually by the exchange matching it</value>
        [DataMember(Name="last_modified_datetime", EmitDefaultValue=false)]
        public DateTime? LastModifiedDatetime { get; set; }

        /// <summary>
        /// This ID uniquely identifies the market
        /// </summary>
        /// <value>This ID uniquely identifies the market</value>
        [DataMember(Name="market_id", EmitDefaultValue=false)]
        public string MarketId { get; set; }

        /// <summary>
        /// This ID uniquely identifies an order
        /// </summary>
        /// <value>This ID uniquely identifies an order</value>
        [DataMember(Name="original_order_id", EmitDefaultValue=false)]
        public string OriginalOrderId { get; set; }


        /// <summary>
        ///  This price is in percentage basis points.&lt;br&gt; Example: 5000 &#x3D; 50% &lt;br&gt; To convert it to decimal odds, just divide 10000 by it&lt;br&gt; Example: 10000 / 5000 &#x3D; 2.0 (decimal odds).&lt;br&gt; This price has to conform to a valid tick on the exchange; an invalid price error will be returned if it does not.
        /// </summary>
        /// <value> This price is in percentage basis points.&lt;br&gt; Example: 5000 &#x3D; 50% &lt;br&gt; To convert it to decimal odds, just divide 10000 by it&lt;br&gt; Example: 10000 / 5000 &#x3D; 2.0 (decimal odds).&lt;br&gt; This price has to conform to a valid tick on the exchange; an invalid price error will be returned if it does not.</value>
        [DataMember(Name="price", EmitDefaultValue=false)]
        public int? Price { get; set; }

        /// <summary>
        ///      Quantity is the sum of the total pot (back+lay) in case the order is matched&lt;br&gt;     The units are 1/100 of a UK penny.&lt;br&gt;     Example: Quantity 1 &#x3D; 0.0001 GBP&lt;br&gt;     To convert it to back stake, just multiply by the price and divide by 100000000&lt;br&gt;     Example: 100000 (quantity) * 5000 (price) / 100000000 &#x3D; 5 GBP back stake
        /// </summary>
        /// <value>     Quantity is the sum of the total pot (back+lay) in case the order is matched&lt;br&gt;     The units are 1/100 of a UK penny.&lt;br&gt;     Example: Quantity 1 &#x3D; 0.0001 GBP&lt;br&gt;     To convert it to back stake, just multiply by the price and divide by 100000000&lt;br&gt;     Example: 100000 (quantity) * 5000 (price) / 100000000 &#x3D; 5 GBP back stake</value>
        [DataMember(Name="quantity", EmitDefaultValue=false)]
        public int? Quantity { get; set; }

        /// <summary>
        /// The quantity in GBP of the order that was matched
        /// </summary>
        /// <value>The quantity in GBP of the order that was matched</value>
        [DataMember(Name="quantity_filled", EmitDefaultValue=false)]
        public int? QuantityFilled { get; set; }

        /// <summary>
        ///  The quantity in GBP of the order that was matched and pending confirmation.&lt;br&gt; Bets will be subject to an eight second â€˜Pendingâ€™ confirmation delay after being matched.&lt;br&gt; If no significant events occur in this period, the bet is confirmed.&lt;br&gt; If our scouting feed tells us that a material event (a goal, red card, or penalty) or a set-piece event (corner or dangerous free-kick) might have occurred, the Pending period is extended until we get confirmation either way.&lt;br&gt; If subsequent messages confirm that a material event has occurred, we void those bets matched in the preceding eight seconds.&lt;br&gt; This is to protect users from courtsiding and faster feeds.
        /// </summary>
        /// <value> The quantity in GBP of the order that was matched and pending confirmation.&lt;br&gt; Bets will be subject to an eight second â€˜Pendingâ€™ confirmation delay after being matched.&lt;br&gt; If no significant events occur in this period, the bet is confirmed.&lt;br&gt; If our scouting feed tells us that a material event (a goal, red card, or penalty) or a set-piece event (corner or dangerous free-kick) might have occurred, the Pending period is extended until we get confirmation either way.&lt;br&gt; If subsequent messages confirm that a material event has occurred, we void those bets matched in the preceding eight seconds.&lt;br&gt; This is to protect users from courtsiding and faster feeds.</value>
        [DataMember(Name="quantity_filled_pending", EmitDefaultValue=false)]
        public int? QuantityFilledPending { get; set; }

        /// <summary>
        /// The quantity of the order that is matched, but pending confirmation, converted to the user&#x27;s currency
        /// </summary>
        /// <value>The quantity of the order that is matched, but pending confirmation, converted to the user&#x27;s currency</value>
        [DataMember(Name="quantity_filled_pending_user_currency", EmitDefaultValue=false)]
        public int? QuantityFilledPendingUserCurrency { get; set; }

        /// <summary>
        /// The quantity of the order that is matched, converted to the user&#x27;s currency
        /// </summary>
        /// <value>The quantity of the order that is matched, converted to the user&#x27;s currency</value>
        [DataMember(Name="quantity_filled_user_currency", EmitDefaultValue=false)]
        public int? QuantityFilledUserCurrency { get; set; }

        /// <summary>
        /// The quantity in GBP of the order that is still unmatched
        /// </summary>
        /// <value>The quantity in GBP of the order that is still unmatched</value>
        [DataMember(Name="quantity_unfilled", EmitDefaultValue=false)]
        public int? QuantityUnfilled { get; set; }

        /// <summary>
        /// The quantity of the order that is unmatched, converted to the user&#x27;s currency
        /// </summary>
        /// <value>The quantity of the order that is unmatched, converted to the user&#x27;s currency</value>
        [DataMember(Name="quantity_unfilled_user_currency", EmitDefaultValue=false)]
        public int? QuantityUnfilledUserCurrency { get; set; }

        /// <summary>
        ///      Quantity is the sum of the total pot (back+lay) in case the order is matched&lt;br&gt;     The units are 1/10000 * one unit of the user&#x27;s currency.&lt;br&gt;     Example: Quantity 1 &#x3D; 0.0001 GBP&lt;br&gt;     To convert it to back stake, just multiply by the price and divide by 100000000&lt;br&gt;     Example: 100000 (quantity) * 5000 (price) / 100000000 &#x3D; 5 GBP back stake
        /// </summary>
        /// <value>     Quantity is the sum of the total pot (back+lay) in case the order is matched&lt;br&gt;     The units are 1/10000 * one unit of the user&#x27;s currency.&lt;br&gt;     Example: Quantity 1 &#x3D; 0.0001 GBP&lt;br&gt;     To convert it to back stake, just multiply by the price and divide by 100000000&lt;br&gt;     Example: 100000 (quantity) * 5000 (price) / 100000000 &#x3D; 5 GBP back stake</value>
        [DataMember(Name="quantity_user_currency", EmitDefaultValue=false)]
        public int? QuantityUserCurrency { get; set; }

        /// <summary>
        /// This refers to the sequence number in the account activity - statement endpoint
        /// </summary>
        /// <value>This refers to the sequence number in the account activity - statement endpoint</value>
        [DataMember(Name="sequence_number", EmitDefaultValue=false)]
        public int? SequenceNumber { get; set; }




        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class OrderResponse1 {\n");
            sb.Append("  AveragePriceMatched: ").Append(AveragePriceMatched).Append("\n");
            sb.Append("  ContractId: ").Append(ContractId).Append("\n");
            sb.Append("  CreatedDatetime: ").Append(CreatedDatetime).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Label: ").Append(Label).Append("\n");
            sb.Append("  LastModifiedDatetime: ").Append(LastModifiedDatetime).Append("\n");
            sb.Append("  MarketId: ").Append(MarketId).Append("\n");
            sb.Append("  OriginalOrderId: ").Append(OriginalOrderId).Append("\n");
            sb.Append("  Outcome: ").Append(Outcome).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  Quantity: ").Append(Quantity).Append("\n");
            sb.Append("  QuantityFilled: ").Append(QuantityFilled).Append("\n");
            sb.Append("  QuantityFilledPending: ").Append(QuantityFilledPending).Append("\n");
            sb.Append("  QuantityFilledPendingUserCurrency: ").Append(QuantityFilledPendingUserCurrency).Append("\n");
            sb.Append("  QuantityFilledUserCurrency: ").Append(QuantityFilledUserCurrency).Append("\n");
            sb.Append("  QuantityUnfilled: ").Append(QuantityUnfilled).Append("\n");
            sb.Append("  QuantityUnfilledUserCurrency: ").Append(QuantityUnfilledUserCurrency).Append("\n");
            sb.Append("  QuantityUserCurrency: ").Append(QuantityUserCurrency).Append("\n");
            sb.Append("  SequenceNumber: ").Append(SequenceNumber).Append("\n");
            sb.Append("  Side: ").Append(Side).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OrderResponse1);
        }

        /// <summary>
        /// Returns true if OrderResponse1 instances are equal
        /// </summary>
        /// <param name="input">Instance of OrderResponse1 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OrderResponse1 input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.AveragePriceMatched == input.AveragePriceMatched ||
                    (this.AveragePriceMatched != null &&
                    this.AveragePriceMatched.Equals(input.AveragePriceMatched))
                ) && 
                (
                    this.ContractId == input.ContractId ||
                    (this.ContractId != null &&
                    this.ContractId.Equals(input.ContractId))
                ) && 
                (
                    this.CreatedDatetime == input.CreatedDatetime ||
                    (this.CreatedDatetime != null &&
                    this.CreatedDatetime.Equals(input.CreatedDatetime))
                ) && 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.Label == input.Label ||
                    (this.Label != null &&
                    this.Label.Equals(input.Label))
                ) && 
                (
                    this.LastModifiedDatetime == input.LastModifiedDatetime ||
                    (this.LastModifiedDatetime != null &&
                    this.LastModifiedDatetime.Equals(input.LastModifiedDatetime))
                ) && 
                (
                    this.MarketId == input.MarketId ||
                    (this.MarketId != null &&
                    this.MarketId.Equals(input.MarketId))
                ) && 
                (
                    this.OriginalOrderId == input.OriginalOrderId ||
                    (this.OriginalOrderId != null &&
                    this.OriginalOrderId.Equals(input.OriginalOrderId))
                ) && 
                (
                    this.Outcome == input.Outcome ||
                    (this.Outcome != null &&
                    this.Outcome.Equals(input.Outcome))
                ) && 
                (
                    this.Price == input.Price ||
                    (this.Price != null &&
                    this.Price.Equals(input.Price))
                ) && 
                (
                    this.Quantity == input.Quantity ||
                    (this.Quantity != null &&
                    this.Quantity.Equals(input.Quantity))
                ) && 
                (
                    this.QuantityFilled == input.QuantityFilled ||
                    (this.QuantityFilled != null &&
                    this.QuantityFilled.Equals(input.QuantityFilled))
                ) && 
                (
                    this.QuantityFilledPending == input.QuantityFilledPending ||
                    (this.QuantityFilledPending != null &&
                    this.QuantityFilledPending.Equals(input.QuantityFilledPending))
                ) && 
                (
                    this.QuantityFilledPendingUserCurrency == input.QuantityFilledPendingUserCurrency ||
                    (this.QuantityFilledPendingUserCurrency != null &&
                    this.QuantityFilledPendingUserCurrency.Equals(input.QuantityFilledPendingUserCurrency))
                ) && 
                (
                    this.QuantityFilledUserCurrency == input.QuantityFilledUserCurrency ||
                    (this.QuantityFilledUserCurrency != null &&
                    this.QuantityFilledUserCurrency.Equals(input.QuantityFilledUserCurrency))
                ) && 
                (
                    this.QuantityUnfilled == input.QuantityUnfilled ||
                    (this.QuantityUnfilled != null &&
                    this.QuantityUnfilled.Equals(input.QuantityUnfilled))
                ) && 
                (
                    this.QuantityUnfilledUserCurrency == input.QuantityUnfilledUserCurrency ||
                    (this.QuantityUnfilledUserCurrency != null &&
                    this.QuantityUnfilledUserCurrency.Equals(input.QuantityUnfilledUserCurrency))
                ) && 
                (
                    this.QuantityUserCurrency == input.QuantityUserCurrency ||
                    (this.QuantityUserCurrency != null &&
                    this.QuantityUserCurrency.Equals(input.QuantityUserCurrency))
                ) && 
                (
                    this.SequenceNumber == input.SequenceNumber ||
                    (this.SequenceNumber != null &&
                    this.SequenceNumber.Equals(input.SequenceNumber))
                ) && 
                (
                    this.Side == input.Side ||
                    (this.Side != null &&
                    this.Side.Equals(input.Side))
                ) && 
                (
                    this.State == input.State ||
                    (this.State != null &&
                    this.State.Equals(input.State))
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.AveragePriceMatched != null)
                    hashCode = hashCode * 59 + this.AveragePriceMatched.GetHashCode();
                if (this.ContractId != null)
                    hashCode = hashCode * 59 + this.ContractId.GetHashCode();
                if (this.CreatedDatetime != null)
                    hashCode = hashCode * 59 + this.CreatedDatetime.GetHashCode();
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.Label != null)
                    hashCode = hashCode * 59 + this.Label.GetHashCode();
                if (this.LastModifiedDatetime != null)
                    hashCode = hashCode * 59 + this.LastModifiedDatetime.GetHashCode();
                if (this.MarketId != null)
                    hashCode = hashCode * 59 + this.MarketId.GetHashCode();
                if (this.OriginalOrderId != null)
                    hashCode = hashCode * 59 + this.OriginalOrderId.GetHashCode();
                if (this.Outcome != null)
                    hashCode = hashCode * 59 + this.Outcome.GetHashCode();
                if (this.Price != null)
                    hashCode = hashCode * 59 + this.Price.GetHashCode();
                if (this.Quantity != null)
                    hashCode = hashCode * 59 + this.Quantity.GetHashCode();
                if (this.QuantityFilled != null)
                    hashCode = hashCode * 59 + this.QuantityFilled.GetHashCode();
                if (this.QuantityFilledPending != null)
                    hashCode = hashCode * 59 + this.QuantityFilledPending.GetHashCode();
                if (this.QuantityFilledPendingUserCurrency != null)
                    hashCode = hashCode * 59 + this.QuantityFilledPendingUserCurrency.GetHashCode();
                if (this.QuantityFilledUserCurrency != null)
                    hashCode = hashCode * 59 + this.QuantityFilledUserCurrency.GetHashCode();
                if (this.QuantityUnfilled != null)
                    hashCode = hashCode * 59 + this.QuantityUnfilled.GetHashCode();
                if (this.QuantityUnfilledUserCurrency != null)
                    hashCode = hashCode * 59 + this.QuantityUnfilledUserCurrency.GetHashCode();
                if (this.QuantityUserCurrency != null)
                    hashCode = hashCode * 59 + this.QuantityUserCurrency.GetHashCode();
                if (this.SequenceNumber != null)
                    hashCode = hashCode * 59 + this.SequenceNumber.GetHashCode();
                if (this.Side != null)
                    hashCode = hashCode * 59 + this.Side.GetHashCode();
                if (this.State != null)
                    hashCode = hashCode * 59 + this.State.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
