/* 
 * Smarkets HTTP API
 *
 * This is the HTTP trading API for Smarkets. It can be used to trade on our exchange.     <br><br>For authenticated requests:<br>     <ul>     <li>Get a session token using the login route:     <a class=\"nostyle\" href=\"#/sessions/create_session\"><span>GET /v3/sessions/</span></a></li>     <li>Click on 'Authorize ðŸ”“', enter your token after 'Session-Token ' and click on the 'Authorize' button</li>     </ul>     <p>In order to place bets and get the latest prices without restrictions     using this API, you need to be a Smarkets API user.<br></p>     <p>To become one, please fill <a href=\"https://docs.google.com/forms/d/1qI8RqypNimakPx- bmoUE_lA0YSP3YogKfL8N14STNSM/viewform?edit_requested=true\">this form</a>.</p>     <p>For questions and feedback about the API, use <a href=\"https://community.smarkets.com/c/developers\">our forum</a>.</p>     <p>The API is not public, but we are granting users access on an ongoing basis.</p>     <p>You can find some sample code to help you bootstrap your integration <a href=\"https://github.com/ smarkets/smk_trading_bot\">here</a>.</p>     
 *
 * OpenAPI spec version: 3
 * Contact: api@smarkets.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IEventsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Retrieve the current states for events by id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>EventStates</returns>
        EventStates GetEventStates (List<int?> eventIds);

        /// <summary>
        /// Retrieve the current states for events by id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>ApiResponse of EventStates</returns>
        ApiResponse<EventStates> GetEventStatesWithHttpInfo (List<int?> eventIds);
        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on.
        /// </summary>
        /// <remarks>
        /// ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Events</returns>
        Events GetEvents (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null);

        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on.
        /// </summary>
        /// <remarks>
        /// ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>ApiResponse of Events</returns>
        ApiResponse<Events> GetEventsWithHttpInfo (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null);
        /// <summary>
        /// Retrieve events by their event ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Events</returns>
        Events GetEventsByIds (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null);

        /// <summary>
        /// Retrieve events by their event ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>ApiResponse of Events</returns>
        ApiResponse<Events> GetEventsByIdsWithHttpInfo (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null);
        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it.
        /// </summary>
        /// <remarks>
        /// ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>Dictionary&lt;string, Object&gt;</returns>
        Dictionary<string, Object> GetLeagueTable (int? eventId);

        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it.
        /// </summary>
        /// <remarks>
        /// ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>ApiResponse of Dictionary&lt;string, Object&gt;</returns>
        ApiResponse<Dictionary<string, Object>> GetLeagueTableWithHttpInfo (int? eventId);
        /// <summary>
        /// Retrieve stats for multiple events.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>MultipleEventStats</returns>
        MultipleEventStats GetStatsMultipleEvents (List<int?> eventIds);

        /// <summary>
        /// Retrieve stats for multiple events.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>ApiResponse of MultipleEventStats</returns>
        ApiResponse<MultipleEventStats> GetStatsMultipleEventsWithHttpInfo (List<int?> eventIds);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Retrieve the current states for events by id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>Task of EventStates</returns>
        System.Threading.Tasks.Task<EventStates> GetEventStatesAsync (List<int?> eventIds);

        /// <summary>
        /// Retrieve the current states for events by id.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>Task of ApiResponse (EventStates)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventStates>> GetEventStatesAsyncWithHttpInfo (List<int?> eventIds);
        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on.
        /// </summary>
        /// <remarks>
        /// ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of Events</returns>
        System.Threading.Tasks.Task<Events> GetEventsAsync (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null);

        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on.
        /// </summary>
        /// <remarks>
        /// ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of ApiResponse (Events)</returns>
        System.Threading.Tasks.Task<ApiResponse<Events>> GetEventsAsyncWithHttpInfo (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null);
        /// <summary>
        /// Retrieve events by their event ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of Events</returns>
        System.Threading.Tasks.Task<Events> GetEventsByIdsAsync (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null);

        /// <summary>
        /// Retrieve events by their event ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of ApiResponse (Events)</returns>
        System.Threading.Tasks.Task<ApiResponse<Events>> GetEventsByIdsAsyncWithHttpInfo (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null);
        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it.
        /// </summary>
        /// <remarks>
        /// ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>Task of Dictionary&lt;string, Object&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, Object>> GetLeagueTableAsync (int? eventId);

        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it.
        /// </summary>
        /// <remarks>
        /// ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, Object&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dictionary<string, Object>>> GetLeagueTableAsyncWithHttpInfo (int? eventId);
        /// <summary>
        /// Retrieve stats for multiple events.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>Task of MultipleEventStats</returns>
        System.Threading.Tasks.Task<MultipleEventStats> GetStatsMultipleEventsAsync (List<int?> eventIds);

        /// <summary>
        /// Retrieve stats for multiple events.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>Task of ApiResponse (MultipleEventStats)</returns>
        System.Threading.Tasks.Task<ApiResponse<MultipleEventStats>> GetStatsMultipleEventsAsyncWithHttpInfo (List<int?> eventIds);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class EventsApi : IEventsApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="EventsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EventsApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventsApi"/> class
        /// </summary>
        /// <returns></returns>
        public EventsApi()
        {
            this.Configuration = IO.Swagger.Client.Configuration.Default;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public EventsApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Retrieve the current states for events by id. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>EventStates</returns>
        public EventStates GetEventStates (List<int?> eventIds)
        {
             ApiResponse<EventStates> localVarResponse = GetEventStatesWithHttpInfo(eventIds);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve the current states for events by id. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>ApiResponse of EventStates</returns>
        public ApiResponse< EventStates > GetEventStatesWithHttpInfo (List<int?> eventIds)
        {
            // verify the required parameter 'eventIds' is set
            if (eventIds == null)
                throw new ApiException(400, "Missing required parameter 'eventIds' when calling EventsApi->GetEventStates");

            var localVarPath = "/v3/events/{event_ids}/states/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventIds != null) localVarPathParams.Add("event_ids", this.Configuration.ApiClient.ParameterToString(eventIds)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventStates", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventStates>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventStates) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventStates)));
        }

        /// <summary>
        /// Retrieve the current states for events by id. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>Task of EventStates</returns>
        public async System.Threading.Tasks.Task<EventStates> GetEventStatesAsync (List<int?> eventIds)
        {
             ApiResponse<EventStates> localVarResponse = await GetEventStatesAsyncWithHttpInfo(eventIds);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve the current states for events by id. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <returns>Task of ApiResponse (EventStates)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventStates>> GetEventStatesAsyncWithHttpInfo (List<int?> eventIds)
        {
            // verify the required parameter 'eventIds' is set
            if (eventIds == null)
                throw new ApiException(400, "Missing required parameter 'eventIds' when calling EventsApi->GetEventStates");

            var localVarPath = "/v3/events/{event_ids}/states/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventIds != null) localVarPathParams.Add("event_ids", this.Configuration.ApiClient.ParameterToString(eventIds)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventStates", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventStates>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventStates) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventStates)));
        }

        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on. ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Events</returns>
        public Events GetEvents (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null)
        {
             ApiResponse<Events> localVarResponse = GetEventsWithHttpInfo(id, inplayEnabled, state, type, typeDomain, typeScope, withNewType, parentId, startDatetimeMin, startDatetimeMax, lastModifiedMin, lastModifiedMax, paginationLastDisplayOrder, paginationLastStartDatetime, paginationLastId, paginationLastName, sort, limit, includeHidden, jurisdiction);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on. ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>ApiResponse of Events</returns>
        public ApiResponse< Events > GetEventsWithHttpInfo (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null)
        {

            var localVarPath = "/v3/events/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (inplayEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inplay_enabled", inplayEnabled)); // query parameter
            if (state != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "state", state)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter
            if (typeDomain != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type_domain", typeDomain)); // query parameter
            if (typeScope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type_scope", typeScope)); // query parameter
            if (withNewType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "with_new_type", withNewType)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "parent_id", parentId)); // query parameter
            if (startDatetimeMin != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_min", startDatetimeMin)); // query parameter
            if (startDatetimeMax != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_max", startDatetimeMax)); // query parameter
            if (lastModifiedMin != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_modified_min", lastModifiedMin)); // query parameter
            if (lastModifiedMax != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_modified_max", lastModifiedMax)); // query parameter
            if (paginationLastDisplayOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_display_order", paginationLastDisplayOrder)); // query parameter
            if (paginationLastStartDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_start_datetime", paginationLastStartDatetime)); // query parameter
            if (paginationLastId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_id", paginationLastId)); // query parameter
            if (paginationLastName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_name", paginationLastName)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (includeHidden != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_hidden", includeHidden)); // query parameter
            if (jurisdiction != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jurisdiction", jurisdiction)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEvents", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Events>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Events) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Events)));
        }

        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on. ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of Events</returns>
        public async System.Threading.Tasks.Task<Events> GetEventsAsync (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null)
        {
             ApiResponse<Events> localVarResponse = await GetEventsAsyncWithHttpInfo(id, inplayEnabled, state, type, typeDomain, typeScope, withNewType, parentId, startDatetimeMin, startDatetimeMax, lastModifiedMin, lastModifiedMax, paginationLastDisplayOrder, paginationLastStartDatetime, paginationLastId, paginationLastName, sort, limit, includeHidden, jurisdiction);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve events that are available on Smarkets to bet on. ## Description Events in Smarkets follow a tree structure per sport, where events can have several child events, but only one parent event.&lt;br&gt; As an example for football, we have:&lt;ul&gt; &lt;li&gt;The root event which is the sport - Football &lt;li&gt;Child events which are leagues - Premier League, La Liga, etc &lt;li&gt;Grandchild events which are football matches - Man U vs Chelsea, ... &lt;/ul&gt;&lt;br&gt; &lt;p&gt;In the case of most sports, we have 3 levels in the tree. However, there are cases where we can have a different number.&lt;/p&gt; &lt;p&gt;To identify whether an event is a leaf node in this tree, one can look at the bettable flag.&lt;/p&gt; &lt;p&gt;Only leaf events can have markets, which in turn will have contracts.&lt;/p&gt;  
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Event IDs to filter by (optional)</param>
        /// <param name="inplayEnabled">True if trading will be open when the markets go live in-play (optional)</param>
        /// <param name="state">Event states to filter by (optional, default to [&quot;new&quot;,&quot;upcoming&quot;,&quot;live&quot;])</param>
        /// <param name="type">Event types to filter by (optional)</param>
        /// <param name="typeDomain"> Allows filtering by &#x27;domains&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The domain of an event denotes the category of events this event belongs to. In most cases this will be the sport (football, tennis, golf, etc) but for non-sports the domain could be politics, tv_and_entertainment, to mention some examples. If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="typeScope"> Allows filtering by &#x27;scopes&#x27; - a feature of the new, improved typing system for events.&lt;br&gt; The scope of an event denotes the kind of event you want, potential values include single_event (your typical football match, horse race, political event), outright (an event who&#x27;s outcome spans multiple events), acca (an accumulator), etc.&lt;br&gt; If you want to use this, you might also want to opt into the new typing system (see &#x60;with_new_type&#x60;).              (optional)</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="parentId">Filter by events with these parent IDs (optional)</param>
        /// <param name="startDatetimeMin">When the event is scheduled to go live (optional)</param>
        /// <param name="startDatetimeMax">When the event is scheduled to go live (optional)</param>
        /// <param name="lastModifiedMin">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="lastModifiedMax">The timestamp when any of the properties of the event was last modified (optional)</param>
        /// <param name="paginationLastDisplayOrder"> Display order for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by display_order,... (optional)</param>
        /// <param name="paginationLastStartDatetime"> Start datetime for the last event of the previous page.&lt;br&gt; This parameter should be used in conjunction with sorting by start_datetime (optional)</param>
        /// <param name="paginationLastId"> The last event id from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by id (optional)</param>
        /// <param name="paginationLastName"> The name of the last event from the previous page, so we can retrieve the subsequent events.&lt;br&gt; This should be used in conjunction with sorting by name (optional)</param>
        /// <param name="sort"> The sorting order for the resulting events.&lt;br&gt; It should be used in conjunction with pagination parameters.&lt;br&gt; The default and recommended sorting order and pagination is by event id.&lt;br&gt; The links to the next page returned on every request help clients navigate through all the relevant events  (optional, default to id)</param>
        /// <param name="limit">The number of events to retrieve in the API call (optional, default to 20)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to false)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of ApiResponse (Events)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Events>> GetEventsAsyncWithHttpInfo (List<string> id = null, bool? inplayEnabled = null, List<string> state = null, List<string> type = null, List<string> typeDomain = null, List<string> typeScope = null, bool? withNewType = null, List<string> parentId = null, DateTime? startDatetimeMin = null, DateTime? startDatetimeMax = null, DateTime? lastModifiedMin = null, DateTime? lastModifiedMax = null, int? paginationLastDisplayOrder = null, DateTime? paginationLastStartDatetime = null, string paginationLastId = null, string paginationLastName = null, string sort = null, int? limit = null, bool? includeHidden = null, string jurisdiction = null)
        {

            var localVarPath = "/v3/events/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (inplayEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inplay_enabled", inplayEnabled)); // query parameter
            if (state != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "state", state)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter
            if (typeDomain != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type_domain", typeDomain)); // query parameter
            if (typeScope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type_scope", typeScope)); // query parameter
            if (withNewType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "with_new_type", withNewType)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "parent_id", parentId)); // query parameter
            if (startDatetimeMin != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_min", startDatetimeMin)); // query parameter
            if (startDatetimeMax != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_max", startDatetimeMax)); // query parameter
            if (lastModifiedMin != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_modified_min", lastModifiedMin)); // query parameter
            if (lastModifiedMax != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_modified_max", lastModifiedMax)); // query parameter
            if (paginationLastDisplayOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_display_order", paginationLastDisplayOrder)); // query parameter
            if (paginationLastStartDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_start_datetime", paginationLastStartDatetime)); // query parameter
            if (paginationLastId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_id", paginationLastId)); // query parameter
            if (paginationLastName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pagination_last_name", paginationLastName)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (includeHidden != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_hidden", includeHidden)); // query parameter
            if (jurisdiction != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jurisdiction", jurisdiction)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEvents", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Events>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Events) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Events)));
        }

        /// <summary>
        /// Retrieve events by their event ids. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Events</returns>
        public Events GetEventsByIds (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null)
        {
             ApiResponse<Events> localVarResponse = GetEventsByIdsWithHttpInfo(eventIds, withNewType, includeHidden, jurisdiction);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve events by their event ids. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>ApiResponse of Events</returns>
        public ApiResponse< Events > GetEventsByIdsWithHttpInfo (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null)
        {
            // verify the required parameter 'eventIds' is set
            if (eventIds == null)
                throw new ApiException(400, "Missing required parameter 'eventIds' when calling EventsApi->GetEventsByIds");

            var localVarPath = "/v3/events/{event_ids}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventIds != null) localVarPathParams.Add("event_ids", this.Configuration.ApiClient.ParameterToString(eventIds)); // path parameter
            if (withNewType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "with_new_type", withNewType)); // query parameter
            if (includeHidden != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_hidden", includeHidden)); // query parameter
            if (jurisdiction != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jurisdiction", jurisdiction)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsByIds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Events>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Events) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Events)));
        }

        /// <summary>
        /// Retrieve events by their event ids. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of Events</returns>
        public async System.Threading.Tasks.Task<Events> GetEventsByIdsAsync (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null)
        {
             ApiResponse<Events> localVarResponse = await GetEventsByIdsAsyncWithHttpInfo(eventIds, withNewType, includeHidden, jurisdiction);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve events by their event ids. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">Event IDs to filter by&lt;br&gt;maxItems:300</param>
        /// <param name="withNewType"> Enables a new, improved typing system for events.&lt;br&gt; If this flag is set to true, the format of the type field in the event response will change.&lt;br&gt; Users of the API are urged to make use of the new typing system, as the old typing system will be deprecated in the next version of the API. (optional, default to false)</param>
        /// <param name="includeHidden">Choose to include in the response events that are not visible on the website. Hidden events may not be displayed for a varied number of reasons (for example the start date is too far away). Betting is not available for hidden events. (optional, default to true)</param>
        /// <param name="jurisdiction">Jurisdiction of user (optional)</param>
        /// <returns>Task of ApiResponse (Events)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Events>> GetEventsByIdsAsyncWithHttpInfo (List<int?> eventIds, bool? withNewType = null, bool? includeHidden = null, string jurisdiction = null)
        {
            // verify the required parameter 'eventIds' is set
            if (eventIds == null)
                throw new ApiException(400, "Missing required parameter 'eventIds' when calling EventsApi->GetEventsByIds");

            var localVarPath = "/v3/events/{event_ids}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventIds != null) localVarPathParams.Add("event_ids", this.Configuration.ApiClient.ParameterToString(eventIds)); // path parameter
            if (withNewType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "with_new_type", withNewType)); // query parameter
            if (includeHidden != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_hidden", includeHidden)); // query parameter
            if (jurisdiction != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jurisdiction", jurisdiction)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsByIds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Events>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Events) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Events)));
        }

        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it. ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>Dictionary&lt;string, Object&gt;</returns>
        public Dictionary<string, Object> GetLeagueTable (int? eventId)
        {
             ApiResponse<Dictionary<string, Object>> localVarResponse = GetLeagueTableWithHttpInfo(eventId);
             return localVarResponse.Data;
        }

        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it. ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>ApiResponse of Dictionary&lt;string, Object&gt;</returns>
        public ApiResponse< Dictionary<string, Object> > GetLeagueTableWithHttpInfo (int? eventId)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventsApi->GetLeagueTable");

            var localVarPath = "/v3/events/{event_id}/league_table/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLeagueTable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, Object>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Dictionary<string, Object>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, Object>)));
        }

        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it. ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>Task of Dictionary&lt;string, Object&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, Object>> GetLeagueTableAsync (int? eventId)
        {
             ApiResponse<Dictionary<string, Object>> localVarResponse = await GetLeagueTableAsyncWithHttpInfo(eventId);
             return localVarResponse.Data;

        }

        /// <summary>
        ///      Given a smarkets competition id returns the league tables for it. ## Description Args:     event_id (int): The event id of the competition Returns:     JSONResponse: Returns a dictionary of the competitions present for that node   
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId"></param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, Object&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Dictionary<string, Object>>> GetLeagueTableAsyncWithHttpInfo (int? eventId)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventsApi->GetLeagueTable");

            var localVarPath = "/v3/events/{event_id}/league_table/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLeagueTable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, Object>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Dictionary<string, Object>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, Object>)));
        }

        /// <summary>
        /// Retrieve stats for multiple events. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>MultipleEventStats</returns>
        public MultipleEventStats GetStatsMultipleEvents (List<int?> eventIds)
        {
             ApiResponse<MultipleEventStats> localVarResponse = GetStatsMultipleEventsWithHttpInfo(eventIds);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve stats for multiple events. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>ApiResponse of MultipleEventStats</returns>
        public ApiResponse< MultipleEventStats > GetStatsMultipleEventsWithHttpInfo (List<int?> eventIds)
        {
            // verify the required parameter 'eventIds' is set
            if (eventIds == null)
                throw new ApiException(400, "Missing required parameter 'eventIds' when calling EventsApi->GetStatsMultipleEvents");

            var localVarPath = "/v3/events/{event_ids}/stats/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventIds != null) localVarPathParams.Add("event_ids", this.Configuration.ApiClient.ParameterToString(eventIds)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStatsMultipleEvents", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MultipleEventStats>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (MultipleEventStats) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(MultipleEventStats)));
        }

        /// <summary>
        /// Retrieve stats for multiple events. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>Task of MultipleEventStats</returns>
        public async System.Threading.Tasks.Task<MultipleEventStats> GetStatsMultipleEventsAsync (List<int?> eventIds)
        {
             ApiResponse<MultipleEventStats> localVarResponse = await GetStatsMultipleEventsAsyncWithHttpInfo(eventIds);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve stats for multiple events. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventIds">maxItems:300</param>
        /// <returns>Task of ApiResponse (MultipleEventStats)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MultipleEventStats>> GetStatsMultipleEventsAsyncWithHttpInfo (List<int?> eventIds)
        {
            // verify the required parameter 'eventIds' is set
            if (eventIds == null)
                throw new ApiException(400, "Missing required parameter 'eventIds' when calling EventsApi->GetStatsMultipleEvents");

            var localVarPath = "/v3/events/{event_ids}/stats/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventIds != null) localVarPathParams.Add("event_ids", this.Configuration.ApiClient.ParameterToString(eventIds)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStatsMultipleEvents", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MultipleEventStats>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (MultipleEventStats) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(MultipleEventStats)));
        }

    }
}
